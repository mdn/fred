import { readFile, writeFile } from "node:fs/promises";

import path from "node:path";

import { fileURLToPath } from "node:url";

import {
  Comment,
  Identifier,
  Message,
  Pattern,
  Resource,
  TextElement,
  parse,
  serialize,
} from "@fluent/syntax";
import { Node, Project, SyntaxKind } from "ts-morph";

/**
 * @import { PropertyAccessExpression, TaggedTemplateExpression } from "ts-morph";
 */

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const EDIT_WARNING = `WARNING: do not edit this file, it's automatically generated by ExtractL10nPlugin.
If you need to manually add strings, do so in ./locales/en-US.ftl. See ./README.md for more details.`;

/**
 * @param {{ lint?: boolean }} [options]
 */
export async function extract(options = {}) {
  const manualEntries = await getManualEntries(
    fileURLToPath(import.meta.resolve("../locales/en-US.ftl")),
  );
  const tags = scrapeL10nTags(
    path.join(__dirname, "..", "..", "components", "**", "*.js"),
  );

  const fluentResource = new Resource([
    new Comment(EDIT_WARNING),
    ...manualEntries,
    ...[...tags].map(
      ([key, value]) =>
        new Message(new Identifier(key), new Pattern([new TextElement(value)])),
    ),
  ]);

  const output = serialize(fluentResource, {});
  const outputPath = fileURLToPath(import.meta.resolve("../template.ftl"));

  if (options.lint) {
    const existing = await readFile(outputPath, "utf8");
    if (existing !== output) {
      throw new Error(
        "l10n template.ftl is out of date. Run `npm run l10n:extract` to update.",
      );
    }
  } else {
    await writeFile(outputPath, output, "utf8");
  }
}

/**
 * @param {string} path Path to fluent file
 */
export async function getManualEntries(path) {
  const manualStrings = await readFile(path, "utf8");
  const fluentResource = parse(manualStrings, {});
  return fluentResource.body.filter(
    (entry) =>
      !(
        entry instanceof Comment &&
        (entry.content.startsWith("WARNING") ||
          entry.content.startsWith("TODO"))
      ),
  );
}

/**
 * @param {string} glob Files to scrape strings from
 */
export function scrapeL10nTags(glob) {
  const project = new Project({});
  project.addSourceFilesAtPaths(glob);

  /** @type {Map<string, string>} */
  const map = new Map();

  for (const file of project.getSourceFiles()) {
    for (const taggedTemplate of file.getDescendantsOfKind(
      SyntaxKind.TaggedTemplateExpression,
    )) {
      const tagNode = taggedTemplate.getTag();
      if (Node.isCallExpression(tagNode)) {
        // e.g. this.l10n("foobar")`barfoo`
        const expr = tagNode.getExpression();
        if (Node.isPropertyAccessExpression(expr) && isL10nTag(expr)) {
          const [arg] = tagNode.getArguments();
          if (Node.isStringLiteral(arg)) {
            const key = arg.getLiteralValue();
            const value = getLiteralValue(taggedTemplate);
            map.set(key, value);
          }
        }
      }
    }
  }

  return map;
}

/**
 * @param {PropertyAccessExpression} tagNode
 */
function isL10nTag(tagNode) {
  return (
    ["context", "this"].includes(tagNode.getExpression().getText()) &&
    "l10n" === tagNode.getName()
  );
}

/**
 * @param {TaggedTemplateExpression} taggedTemplate
 */
function getLiteralValue(taggedTemplate) {
  const template = taggedTemplate.getTemplate();
  if (Node.isNoSubstitutionTemplateLiteral(template)) {
    return template.getLiteralValue();
  } else {
    throw new Error(
      `L10n extractor: \`${taggedTemplate.getText()}\` has substitutions, which we don't support`,
    );
  }
}
